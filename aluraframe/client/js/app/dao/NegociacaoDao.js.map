{"version":3,"sources":["../../app-es6/dao/NegociacaoDao.js"],"names":["Negociacao","NegociacaoDao","connection","_connection","_store","negociacao","Promise","resolve","reject","request","transaction","objectStore","add","onsuccess","e","onerror","console","log","target","error","cursor","openCursor","negociacoes","atual","result","dado","value","push","_data","_quantidade","_valor","continue","name","clear"],"mappings":";;;;;;;;;;;;;;;AAAQA,sB,qBAAAA,U;;;;;;;;;;;;;;;;;;;;;qCAEKC,a;AAET,uCAAYC,UAAZ,EAAwB;AAAA;;AAEpB,yBAAKC,WAAL,GAAmBD,UAAnB;AACA,yBAAKE,MAAL,GAAc,aAAd;AACH;;;;6CAEQC,U,EAAY;AAAA;;AAEjB,+BAAO,IAAIC,OAAJ,CAAY,UAACC,OAAD,EAAUC,MAAV,EAAqB;;AAEpC,gCAAIC,UAAU,MACTN,WADS,CAETO,WAFS,CAEG,CAAC,MAAKN,MAAN,CAFH,EAEiB,WAFjB,EAGTO,WAHS,CAGG,MAAKP,MAHR,EAITQ,GAJS,CAILP,UAJK,CAAd;;AAOA;;;;;;;;;;AAaAI,oCAAQI,SAAR,GAAoB,UAACC,CAAD,EAAO;;AAEvBP;AACH,6BAHD;;AAKAE,oCAAQM,OAAR,GAAkB,aAAK;;AAEnBC,wCAAQC,GAAR,CAAYH,EAAEI,MAAF,CAASC,KAArB;AACAX,uCAAO,yCAAP;AACH,6BAJD;AAKH,yBAhCM,CAAP;AAiCH;;;iDAEW;AAAA;;AAEX,+BAAO,IAAIF,OAAJ,CAAY,UAACC,OAAD,EAASC,MAAT,EAAmB;;AAGrC,gCAAIY,SAAS,OACFjB,WADE,CAEFO,WAFE,CAEU,CAAC,OAAKN,MAAN,CAFV,EAEwB,WAFxB,EAGFO,WAHE,CAGU,OAAKP,MAHf,EAIFiB,UAJE,EAAb;;AAMH,gCAAIC,cAAc,EAAlB;;AAEA;AACA;AACAF,mCAAOP,SAAP,GAAmB,aAAK;;AAEvB;AACA,oCAAIU,QAAQT,EAAEI,MAAF,CAASM,MAArB;;AAEA;AACA,oCAAGD,KAAH,EAAS;;AAER;AACA,wCAAIE,OAAOF,MAAMG,KAAjB;;AAEA;AACA;AACAJ,gDAAYK,IAAZ,CAAiB,IAAI3B,UAAJ,CAAeyB,KAAKG,KAApB,EAA0BH,KAAKI,WAA/B,EAA2CJ,KAAKK,MAAhD,CAAjB;;AAEA;AACAP,0CAAMQ,QAAN;AACA,iCAXD,MAWK;AACJxB,4CAAQe,WAAR;AACA;AACD,6BApBD;;AAsBAF,mCAAOL,OAAP,GAAiB,aAAK;AACrBC,wCAAQC,GAAR,CAAYH,EAAEI,MAAF,CAASC,KAAT,CAAea,IAA3B;AACAxB,uCAAO,uCAAP;AACA,6BAHD;;AAKG;;;;;;;;AAWA,yBAnDM,CAAP;AAoDA;;;iDAEW;AAAA;;AAEX,+BAAO,IAAIF,OAAJ,CAAY,UAACC,OAAD,EAASC,MAAT,EAAoB;;AAEtC,gCAAIC,UAAU,OACHN,WADG,CAEHO,WAFG,CAES,CAAC,OAAKN,MAAN,CAFT,EAEuB,WAFvB,EAGHO,WAHG,CAGS,OAAKP,MAHd,EAIH6B,KAJG,EAAd;;AAMMxB,oCAAQI,SAAR,GAAoB;AAAA,uCAAKN,QAAQ,kCAAR,CAAL;AAAA,6BAApB;;AAEAE,oCAAQM,OAAR,GAAkB,aAAK;;AAEtBC,wCAAQC,GAAR,CAAYH,EAAEI,MAAF,CAASC,KAArB;AACAX,uCAAO,yCAAP;AACA,6BAJD;AAKN,yBAfM,CAAP;AAgBA","file":"NegociacaoDao.js","sourcesContent":["import {Negociacao} from '../models/Negociacao';\r\n\r\nexport class NegociacaoDao {\r\n\r\n    constructor(connection) {\r\n\r\n        this._connection = connection;\r\n        this._store = 'negociacoes';\r\n    }\r\n\r\n    adiciona(negociacao) {\r\n\r\n        return new Promise((resolve, reject) => {\r\n\r\n            let request = this\r\n                ._connection\r\n                .transaction([this._store],\"readwrite\")\r\n                .objectStore(this._store)\r\n                .add(negociacao);\r\n\r\n\r\n            /*\r\n\t\t\t//toda vez que for gravar no Object store primeiro preciso pedir uma transação e dizer qual é o Object store da transação e o tipo\r\n\t\t\tlet transaction = this._connection.transaction([this._store],'readwrite');\r\n\r\n\t\t\t//dessa transação acima eu tenho acesso ao objectStore\r\n\t\t\tlet store = transaction.objectStore(this._store);\r\n\r\n\t\t\t//desse object store eu tenho um metodo add que permite adicionar um objeto dentro dele\r\n\t\t\t//mas o add me retorna uma requisição para poder adicionar\r\n\t\t\tlet request = store.add(negociacao);\r\n\t\t\t*/    \r\n                \r\n\r\n            request.onsuccess = (e) => {\r\n\r\n                resolve();\r\n            };\r\n\r\n            request.onerror = e => {\r\n\r\n                console.log(e.target.error);\r\n                reject('Não foi possível adicionar a negociação');\r\n            };                \r\n        });\r\n    }\r\n\r\n    listaTodos(){\r\n\r\n    \treturn new Promise((resolve,reject) =>{\r\n\r\n\r\n    \t\tlet cursor = this\r\n                ._connection\r\n                .transaction([this._store],\"readwrite\")\r\n                .objectStore(this._store)\r\n                .openCursor();\r\n\r\n\t\t\tlet negociacoes = [];\r\n\r\n\t\t\t//onsuccess é chamado toda vez que cria um cursor\r\n\t\t\t//toda vez que ele for criado ele ira me retornar um ponteiro\r\n\t\t\tcursor.onsuccess = e => {\r\n\r\n\t\t\t\t//e.target.result é o que retorna o ponteiro, ele vai apontar para o primeiro objeto da minha object store se tiver\r\n\t\t\t\tlet atual = e.target.result;\r\n\r\n\t\t\t\t//vc verifica se a dado\r\n\t\t\t\tif(atual){\r\n\r\n\t\t\t\t\t//se a um ponteiro valido com esse atual.value ele pego o valor que a dentro dele\r\n\t\t\t\t\tlet dado = atual.value;\r\n\r\n\t\t\t\t\t//como o dado que é salvo no object store é so um json com os atributos\r\n\t\t\t\t\t//aqui para enserir em negociacao eu vou criar uma instancia de Negociacao e passar o valor para esta instancia\r\n\t\t\t\t\tnegociacoes.push(new Negociacao(dado._data,dado._quantidade,dado._valor));\r\n\r\n\t\t\t\t\t//aqui eu chamo ele passar para o proximo, isso quer dizer ele vai chamar o onsucess novamente, enquanto tiver dado ele ira cair nesse if, quando não houver mais ele ira cair no else\r\n\t\t\t\t\tatual.continue();\r\n\t\t\t\t}else{\r\n\t\t\t\t\tresolve(negociacoes);\r\n\t\t\t\t}\r\n\t\t\t};\r\n\r\n\t\t\tcursor.onerror = e => {\r\n\t\t\t\tconsole.log(e.target.error.name);\r\n\t\t\t\treject('Não foi possivel lista as negociações');\r\n\t\t\t}\t\r\n\r\n    \t\t/*\r\n    \t\tlet transaction = connection.transaction(['negociacoes'],'readwrite');\r\n\r\n\t\t\tlet store = transaction.objectStore('negociacoes');\r\n\r\n\t\t\t\t}else{\r\n\t\t\t\t\tconsole.log(negociacoes);\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t\t*/\r\n\r\n    \t});\r\n    }\r\n\r\n    apagaTodos(){\r\n\r\n    \treturn new Promise((resolve,reject) => {\r\n\r\n    \t\tlet request = this\r\n                ._connection\r\n                .transaction([this._store],\"readwrite\")\r\n                .objectStore(this._store)\r\n                .clear();\r\n\r\n            request.onsuccess = e => resolve('Negociações apagadas com sucesso');\r\n\r\n            request.onerror = e => {\r\n\r\n            \tconsole.log(e.target.error);\r\n            \treject('Não foi possivel apagar  as negociações');\r\n            };\t\r\n    \t});\r\n    }\r\n}"]}