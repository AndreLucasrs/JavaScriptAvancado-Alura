{"version":3,"sources":["../../app-es6/services/HttpService.js"],"names":["HttpService","res","ok","Error","statusText","url","fetch","then","_handleErros","json","dado","headers","method","body","JSON","stringify"],"mappings":";;;;;;IAAMA,W;;;;;;;+BAEQC,G,EAAI;;AAEhB,OAAG,CAACA,IAAIC,EAAR,EAAY,MAAM,IAAIC,KAAJ,CAAUF,IAAIG,UAAd,CAAN;;AAEZ,UAAOH,GAAP;AACA;;;sBAEGI,G,EAAI;AAAA;;AAEP;AACA;AACA;AACA;AACA;AACA,UAAOC,MAAMD,GAAN,EACLE,IADK,CACA;AAAA,WAAO,MAAKC,YAAL,CAAkBP,GAAlB,CAAP;AAAA,IADA,EAELM,IAFK,CAEA;AAAA,WAAON,IAAIQ,IAAJ,EAAP;AAAA,IAFA,CAAP;AAGA;;;uBAEIJ,G,EAAKK,I,EAAM;AAAA;;AAET,UAAOJ,MAAMD,GAAN,EAAW;AACdM,aAAS,EAAE,gBAAgB,kBAAlB,EADK;AAEdC,YAAQ,MAFM;AAGdC,UAAMC,KAAKC,SAAL,CAAeL,IAAf;AAHQ,IAAX,EAKNH,IALM,CAKD;AAAA,WAAO,OAAKC,YAAL,CAAkBP,GAAlB,CAAP;AAAA,IALC,CAAP;AAMN;;;;;;AAIF;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAwEA;AACA","file":"HttpService.js","sourcesContent":["class HttpService {\r\n\r\n\t_handleErros(res){\r\n\r\n\t\tif(!res.ok) throw new Error(res.statusText);\r\n\t\t\r\n\t\treturn res;\r\n\t}\r\n\t\r\n\tget(url){\r\n\r\n\t\t//Fetch API, uma API de busca do JS\r\n\t\t//No escopo global, nós iremos adicionar a variável fetch, no HttpService.js. \r\n\t\t//O resultado dela está no then(), \r\n\t\t//isto significa que o retorno será uma Promise por padrão.\r\n\t\t//vai chamar a url, então verifica se a resposta é ok se for ok então retorna json ou poderia ser texto se quisesse\r\n\t\treturn fetch(url)\r\n\t\t\t.then(res => this._handleErros(res))\r\n\t\t\t.then(res => res.json());\r\n\t}\r\n\r\n\tpost(url, dado) {\r\n\r\n        return fetch(url, {\r\n            headers: { 'Content-Type': 'application/json' },\r\n            method: 'post',\r\n            body: JSON.stringify(dado)\r\n        })\r\n        .then(res => this._handleErros(res))\r\n\t}\r\n}\r\n\r\n\r\n/*\r\n\r\nCodigo antes de usar FETCH API\r\n\r\nget(url){\r\n\r\n\t\t//Padrão de Projeto Promise\r\n\t\treturn new Promise((resolve,reject) => {\r\n\r\n\t\t\tlet xhr = new XMLHttpRequest();\r\n\t\t\t\r\n\t\t\t//isso quer dizer que ele esta preparando pra fazer a requisição, ele não esta fazendo ainda\r\n\t\t\txhr.open(\"GET\",url);\r\n\r\n\t\t\tconfiguração\r\n\t\t\t//essa função vai ser chamada toda vez que o estado do xhr mudar\r\n\t\t\tEsses são os estados\r\n\t\t\t\t0: requisição ainda não iniciada\r\n\t\t\t\t1: conexão com o servidor estabelecida\r\n\t\t\t\t2: requisição recebida\r\n\t\t\t\t3: processando requisição\r\n\t\t\t\t4: requisição está concluída e a resposta está pronta\r\n\t\t\t\r\n\t\t\txhr.onreadystatechange = () => {\r\n\r\n\t\t\t\tif(xhr.readyState == 4){\r\n\r\n\t\t\t\t\tif(xhr.status == 200){\r\n\r\n\t\t\t\t\t\t//xhr.responseText traz a resposta do servido os dados\r\n\t\t\t\t\t\t//JSON.parse recebe um texto que equivale a um JSON e converte esse texto em Objeto JavaScript\r\n\t\t\t\t\t\tresolve(JSON.parse(xhr.responseText));\r\n\t\t\t\t\t} \r\n\t\t\t\t\telse {\r\n\r\n\t\t\t\t\t\treject(xhr.responseText);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t};\r\n\r\n\t\t\t//agora ele ira fazer requisição\r\n\t\t\txhr.send();\r\n\t\t});\r\n\t}\r\n\r\n\tpost(url, dado) {\r\n\r\n            return new Promise((resolve, reject) => {\r\n\r\n                let xhr = new XMLHttpRequest();\r\n                xhr.open(\"POST\", url, true);\r\n                xhr.setRequestHeader(\"Content-type\", \"application/json\");\r\n                xhr.onreadystatechange = () => {\r\n\r\n                    if (xhr.readyState == 4) {\r\n\r\n                        if (xhr.status == 200) {\r\n\r\n                            resolve(JSON.parse(xhr.responseText));\r\n                        } else {\r\n\r\n                            reject(xhr.responseText);\r\n                        }\r\n                    }\r\n                };\r\n                xhr.send(JSON.stringify(dado)); // usando JSON.stringifly para converter objeto em uma string no formato JSON.\r\n        });\r\n    }\t\r\n\r\n*/\r\n\r\n\r\n//Promise\r\n/*\r\nParecerá ser um método síncrono.\r\nNo entanto, ele não é... \r\nPorque ele não devolverá a lista de negociações,\r\nmas, sim, uma promise - que não poderá encontrar o que busca. \r\nA promessa é o resultado futuro de uma operação. \r\nQuando pensamos no conceito de uma promessa, nos vem a ideia de que \r\n\"se você cumprir a promessa, então algo irá acontecer...\". \r\nSeguindo está relação com então, chamaremos o método then() na promise.\r\n*/"]}